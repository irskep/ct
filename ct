#!/usr/local/bin/python

import argparse
import datetime
import os
import sys

config_file_name = '.ctconfig'

commands = {}

def command(name):
    """Declare a command"""
    def dec(func):
        commands[name] = func
        return func
    return dec

def sanitize(name):
    name.replace('/', '_')
    name.replace('\\', '_')
    name.replace(':', '_')
    name.replace('\n', '_')
    return name

def load_config():
    """Load or create the config file"""
    if not os.path.exists(config_file_name):
        init()
    config = {}
    with open(config_file_name) as f:
        for line in f:
            k, v = line.split(':')
            config[k] = v.strip()
    return config

def file_for_current_user(mode='r'):
    """Return the file corresponding to the current user"""
    config = load_config()
    path = '%s.txt' % config['name']
    if mode == 'r' and not os.path.exists(path):
        return None
    else:
        return open(path, mode)

def log(line):
    """Write a line to the current user's file"""
    with file_for_current_user('a') as f:
        f.write(line)

def clocked_in_project():
    """Return True if a user is configured and the last action was a clockin"""
    f = file_for_current_user()
    if f:
        last_line = f.readlines()[-1]
        if 'clockin' in last_line:
            return last_line.split(' clockin ')[0]
    else:
        return False

@command('init')
def init(args=None):
    args = args or []
    parser = argparse.ArgumentParser(prog='ct init',
                                     description='Start tracking time in an empty repository')
    args = parser.parse_args(args)
    
    try:
        name = sanitize(raw_input('Your name in filesystem-legal characters:\n'))
    except EOFError:
        if os.path.exists(config_file_name):
            print 'Keeping old config'
            return
        else:
            print 'Exiting'
            sys.exit[0]
    
    try:
        os.remove(config_file_name)
    except OSError:
        pass    # Doesn't matter
    
    with open(config_file_name, 'w') as f:
        f.write('name: %s\n' % name)
    
    print 'Created config file'

@command ('clockin')
def clockin(args):
    parser = argparse.ArgumentParser(prog='ct clockin',
                                     description='Start logging hours to a project')
    parser.add_argument('project', type=str, action='store',  nargs='+')
    parser.add_argument('-t', '--time', type=str, action='store', default=None,
                        help='Time to log for checkin')
    
    args = parser.parse_args(args)
    
    if clocked_in_project():
        clockout()
    
    proj = ' '.join(args.project)
    
    if args.time:
        clockin_time = dateutil.parse(args.time)
    else:
        clockin_time = datetime.datetime.now()
    
    log('%s clockin %s\n' % (proj, clockin_time.strftime('%d-%m-%Y %H:%M:%S')))
    
    print 'Clocked into %s at %s' % (proj,
                                     clockin_time.strftime('%I:%M %p on %b %d, %Y'))

@command ('clockout')
def clockout(args=None):
    args = args or []
    parser = argparse.ArgumentParser(prog='ct clockout',
                                     description='Stop logging hours to a project')
    parser.add_argument('-t', '--time', type=str, action='store', default=None,
                        help='Time to log for checkin')
    
    args = parser.parse_args(args)
    
    if args.time:
        clockout_time = dateutil.parse(args.time)
    else:
        clockout_time = datetime.datetime.now()
    
    print 'Clocked out of %s at %s' % (clocked_in_project(), 
                                       clockout_time.strftime('%I:%M %p on %b %d, %Y'))
    
    log('clockout %s\n' % (clockout_time.strftime('%d-%m-%Y %H:%M:%S')))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='ct',
                                     description='Git-based time tracking tool')
    parser.add_argument('command', type=str, action='store',
                        choices=commands.keys(),
                        help='init, clockin, or clockout')
    args = parser.parse_args(sys.argv[1:2])
    commands[args.command](sys.argv[2:])
